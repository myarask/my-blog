<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Blog</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="index.js" defer></script>

    <!-- Prism.js CSS (for syntax highlighting) -->
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism-tomorrow.css"
      rel="stylesheet"
    />
    <!-- Prism.js JS (for syntax highlighting) -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-javascript.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-typescript.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-jsx.min.js"></script> -->
  </head>
  <body
    class="bg-gray-100 text-gray-900 grid grid-cols-[250px_1fr] min-h-screen"
  >
    <!-- Navigation -->
    <nav class="bg-blue-600 text-white p-6">
      <a
        href="#"
        class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
        onclick="showSection('home')"
      >
        Home
      </a>

      <h2 class="text-xl font-bold mb-4">Articles</h2>
      <ul>
        <li>
          <a
            href="#state-server-vs-client"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('state-server-vs-client')"
          >
            State: Server vs Client
          </a>
        </li>
        <li>
          <a
            href="#when-to-split"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('when-to-split')"
          >
            Style: When to split a component
          </a>
        </li>
        <li>
          <a
            href="#custom-hooks"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('custom-hooks')"
          >
            Style: Custom hooks
          </a>
        </li>
        <li>
          <a
            href="#style-colocation"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('style-colocation')"
          >
            Style: Colocation
          </a>
        </li>
        <li>
          <a
            href="#performance-prefetching"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('performance-prefetching')"
          >
            Performance: Prefetching
          </a>
        </li>
        <li>
          <a
            href="#performance-size"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('performance-size')"
          >
            Performance: Size
          </a>
        </li>
        <li>
          <a
            href="#barrel-files"
            class="block w-full text-left py-2 px-4 hover:bg-blue-500 rounded"
            onclick="showSection('barrel-files')"
          >
            Performance: Barrel Files
          </a>
        </li>
      </ul>
    </nav>
    <!-- Main Content -->
    <main class="overflow-y-auto h-screen">
      <!-- Home -->
      <section id="home" class="hidden p-6">
        <h1 class="text-2xl font-bold">Welcome to my thoughts on React</h1>
        <p class="mt-4 text-gray-700">Select an article from the sidebar.</p>
      </section>

      <!-- State: Server vs Client -->
      <section id="state-server-vs-client" class="hidden p-6">
        <h1 class="text-2xl font-bold">State: Server vs Client</h1>

        <p class="mt-4 text-gray-700">
          From your app's perspective, the biggest difference between server and 
          client state is that server state is asynchronous while client state is 
          synchronous. The difference in read/write timing is enough to merit their 
          own state management solution. Mixing these states together in the same 
          store will almost always increase the complexity of your app.
        </p>

        <p class="mt-4 text-gray-700">
          For server state, it is recommended to use a server state library like React 
          Query, Apollo Client, or SWR. These libraries are designed to handle the 
          asynchronous nature of server state, and they provide features like caching, 
          background updates, and automatic retries. They also help to keep your 
          components clean and focused on rendering, rather than managing the 
          complexities of server state.
        </p>

        <p class="mt-4 text-gray-700">
          For client state, it is recommended to use a client state library like Zustand, MobX, or
          Redux. These libraries are ideal for the synchronous nature of client state. They are 
          useful for sharing state between components, eliminating prop drilling, and facilitating state
          rehydration.
        </p>

        <p class="mt-4 text-gray-700">
          In practical terms, this means that server and client state should not be mixed into the same store.
          Use the server state library cache to read data from the server. 
        </p>

      </section>

      <!-- Style: Colocation -->
      <section id="style-colocation" class="hidden p-6">
        <h1 class="text-2xl font-bold">Style: colocation</h1>

        <p class="mt-4 text-gray-700">
          By phyically grouping code around features, the developer can access
          it without making jumps around the codebase. Doing this also makes it
          easier to scope pipeline jobs to the affected code.
        </p>

        <p class="mt-4 text-gray-700">
          The following is an example of how files might be named in order to
          group it by feature:
        </p>

        <ul class="mt-4">
          <li>MyComponent.tsx</li>
          <li>MyComponent.test.tsx</li>
          <li>MyComponent.css</li>
          <li>MyComponent.hooks.ts</li>
          <li>MyComponent.hooks.test.ts</li>
          <li>MyComponent.queries.ts</li>
          <li>MyComponent.mutations.ts</li>
          <li>MyComponent.types.ts</li>
        </ul>
      </section>

      <!-- Style: When to split a component -->
      <section id="when-to-split" class="hidden p-6">
        <h1 class="text-2xl font-bold">When to split a component</h1>

        <p class="mt-4 text-gray-700">
          A common question in React is when to split a component. How big is
          too big? When does a component become too complex? The following is a
          set of heuristics to help you manage complexity in your React app.
        </p>

        <h2 class="mt-4 text-xl font-bold">Classification 1: Interactive components</h1>

        <p class="mt-4 text-gray-700">
          Interactive elements like buttons and input fields are often merited to
          their own components.
        </p>

        <p class="mt-4 text-gray-700">
          The first benefit to this heuristic is that it allows the developer 
          to quickly understand the cause and effect of a user interaction.
          The trigger and the outcome are colocated, which minimizes the amount 
          of jumps a reader will perform when reviewing the code.
        </p>

        <p class="mt-4 text-gray-700">
          Secondly, this heuristic can eliminate many unnecessary naming decisions.
          Every click handler may be named "handleClick", and every change handler
          may be named "handleChange". The naming decision is instead found in the 
          component name, which can usually be influenced by the copy in the component. 
          A button element which reads "Confirm Order" may be named "ConfirmOrderButton".
          An input element with a placeholder of "search" may be named "SearchInput".
        </p>

        <h2 class="mt-4 text-xl font-bold">Classification 2: Utility components</h1>

        <p class="mt-4 text-gray-700">
          To reduce complexity in your React components, you will want to keep 
          a separation of concerns with utility operations. For example, let's 
          assume your app will need to initialize a performance monitor and a 
          data analytics service on mount. Rather than mixing these two concerns 
          into a single useEffect, break them into their own components. Utility 
          components are focused on operations, and typically render nothing.
        </p>

        <p class="mt-4 text-gray-700">
          Providers, error boundaries, gates, launchers are some examples of utility components.
        </p>

        <h2 class="mt-4 text-xl font-bold">Classification 3: Layout components</h1>

        <p class="mt-4 text-gray-700">
          When interactive elements and utility components are stripped away, what 
          remains is a layout component. From here, the developer can manage the 
          layout of a view from a single file. Layout components may grow large, but 
          will never be complex. At most, a layout compnent may contain some trivial 
          conditional rendering logic.
        </p>

      </section>

      <!-- Hooks -->
      <section id="custom-hooks" class="hidden p-6">
        <h1 class="text-2xl font-bold">Style: Custom hooks</h1>

        <p class="mt-4 text-gray-700">
          Commonly accessed data wants to be read like this:
        </p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const thing = useThing();
</code>
        </pre>

        <p class="mt-4 text-gray-700">
          Comparing practical examples can explain why:
        </p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
// ✅ Familiar terminology
// ✅ Consistent terminology
// ✅ Data-source agnostic
// ✅ No required parameters
// ✅ Implied memoization
const profile = useProfile();



// ❌ If a hook's scope is too narrow, it becomes harder to describe, find, and re-use.
const staticProfileMedia = useStaticProfileMedia();

// ❌ Mixing terms can mislead the developer.
const user = useProfile();

// ❌ The schema and the state management library become baked into the app, making refactors harder.
const profile = useSelector((state) => state.profile);

// ❌ All consumers of the hook are forced to dig up the required parameter (userId).
const profile = useProfile(userId);

// ❌ The results of the read are not memoized, hurting performance.
const profile = getProfile();



// ⚠️ Using the state management library directly is advantageous for obscure data points.
// ⚠️ There are no scaling benefits for custom hooks that are used only once.
const dataPoint = useSelector((state) => state.my.obscure.data.point);
</code>
        </pre>
      </section>

      <!-- Shared State -->
      <section id="performance-size" class="hidden p-6">
        <h1 class="text-2xl font-bold">Performance: Size</h1>

        <p class="mt-4 text-gray-700">
          Removing abstractions which are used only once will always decrease
          the size of the source code. It will often shrink the size of the
          build, and it might improve the speed of the program.
        </p>

        <p class="mt-4 text-gray-700">Before</p>
        <p class="mt-4 text-gray-700">Average time: 125.52ns</p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const isAprilFools = () => {
  const today = new Date();
  const month = today.getMonth();
  const date = today.getDate();
  return month === Month.April && date === 1;
};

if (isAprilFools()) {
  console.log("April Fools!");
} else {
  console.log("Hello, World!");
}
</code>
</pre>
        <p class="mt-4 text-gray-700">
          Before, Minified (Input: 268 bytes; Output: 173 bytes; Compression:
          35.45%, saving: 95 bytes;)
        </p>
        <p class="mt-4 text-gray-700">Average Time: 125.08ns</p>
        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const isAprilFools=()=>{const o=new Date,l=o.getMonth(),e=o.getDate();return l===Month.April&&1===e};isAprilFools()?console.log("April Fools!"):console.log("Hello, World!");
</code>
        </pre>

        <p class="mt-4 text-gray-700">After</p>
        <p class="mt-4 text-gray-700">Average Time: 122.09ns</p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const today = new Date();

if (today.getMonth() === Month.April && today.getDate() === 1) {
  console.log("April Fools!");
} else {
  console.log("Hello, World!");
}
</code>
        </pre>
        <p class="mt-4 text-gray-700">
          After, Minified (Input: 165 bytes; Output: 130 bytes; Compression:
          21.21%, saving: 35 bytes;)
        </p>
        <p class="mt-4 text-gray-700">Average Time: 121.36ns</p>
        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const today=new Date;today.getMonth()===Month.April&&1===today.getDate()?console.log("April Fools!"):console.log("Hello, World!");
</code>
        </pre>
      </section>

      <!-- Shared State -->
      <section id="performance-prefetching" class="hidden p-6">
        <h1 class="text-2xl font-bold">Performance: Prefetching</h1>

        <p class="mt-4 text-gray-700">
          Tasks can be finished earlier by starting earlier. Your web app should
          begin loading data as soon as it confirmed to be needed.
        </p>

        <p class="mt-4 text-gray-700">
          In this example, there is a MissionPage, which is loaded
          asynchronously. This component mounts after the user decides to see
          the Mission page. The Launcher component starts fetching the data
          needed by the page.
        </p>

        <iframe
          src="https://codesandbox.io/embed/lvkl7p?view=editor&module=%2Fsrc%2Fpages%2FMission%2FMissionLauncher.tsx"
          style="
            width: 100%;
            height: 500px;
            border: 0;
            border-radius: 4px;
            /* overflow: hidden; */
          "
          title="Example"
          allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
          sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
        ></iframe>

        <hr />

        <p class="mt-4 text-gray-700">
          The page component will read the response data synchronously, as it
          will not render until all promises in suspense are resolved.
        </p>

        <iframe
          src="https://codesandbox.io/embed/lvkl7p?view=editor+%2B+preview&module=%2Fsrc%2Fpages%2FMission%2FMissionPage.tsx"
          style="
            width: 100%;
            height: 500px;
            border: 0;
            border-radius: 4px;
            overflow: hidden;
          "
          title="Example"
          allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
          sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
        ></iframe>

        <hr />

        <p class="mt-4 text-gray-700">
          For data that is needed in every session, the fetch operations can be
          started before the React app is mounted.
        </p>

        <iframe
          src="https://codesandbox.io/embed/lvkl7p?view=editor+%2B+preview&module=%2Fsrc%2Fapollo.ts"
          style="
            width: 100%;
            height: 500px;
            border: 0;
            border-radius: 4px;
            overflow: hidden;
          "
          title="launchers-gates (forked)"
          allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
          sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
        ></iframe>
      </section>
    </main>
  </body>
</html>
