<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>On Hooks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Prism.js CSS (for syntax highlighting) -->
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism-tomorrow.css"
      rel="stylesheet"
    />
    <!-- Prism.js JS (for syntax highlighting) -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-jsx.min.js"></script>
  </head>
  <body class="bg-gray-100 text-gray-900">
    <div class="flex min-h-screen">
      <!-- Sidebar (Same as index.html) -->
      <aside class="w-64 bg-blue-600 text-white p-6">
        <h2 class="text-xl font-bold mb-4">Articles</h2>
        <ul>
          <li>
            <a
              href="on-hooks.html"
              class="block w-full text-left py-2 px-4 bg-blue-700 rounded"
            >
              On Hooks
            </a>
          </li>
        </ul>
      </aside>

      <!-- Main Content -->
      <main class="flex-1 p-8 bg-white shadow-md rounded-lg m-6">
        <h1 class="text-2xl font-bold">On Hooks</h1>

        <p class="mt-4 text-gray-700">
          Commonly accessed data wants to be read like this:
        </p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
const thing = useThing();
</code>
        </pre>

        <p class="mt-4 text-gray-700">
          Comparing this pattern with alternatives can explain why:
        </p>

        <pre class="bg-gray-800 text-white p-4 rounded-lg mt-4">
<code class="language-js">
// ✅ Familiar terminology
// ✅ Consistent terminology
// ✅ Data-source agnostic
// ✅ No required parameters
// ✅ Implied memoization
const profile = useProfile();



// ❌ If a hook's scope is too narrow, it becomes harder to describe, find, and re-use.
const staticProfileMedia = useStaticProfileMedia();

// ❌ Mixing terms can mislead the developer.
const user = useProfile();

// ❌ The schema and the state management library become baked into the app, making refactors harder.
const profile = useSelector((state) => state.profile);

// ❌ All consumers of the hook are forced to dig up the required parameter (userId).
const profile = useProfile(userId);

// ❌ The results of the read are not memoized, hurting performance.
const profile = getProfile();



// ⚠️ Using the state management library directly can be advantageous for obscure data points.
// ⚠️ There are no scaling benefits for custom hooks that are used only once.
const dataPoint = useSelector((state) => state.my.obscure.data.point);
</code>
        </pre>

        <a
          href="index.html"
          class="text-blue-500 hover:underline mt-4 inline-block"
          >Back to Home</a
        >
      </main>
    </div>
  </body>
</html>
